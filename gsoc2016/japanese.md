---
title: 成果報告
layout: page
parmalink: /gsoc2016/japanese/
---

[English Page]({{site.url}}/gsoc2016/english/)

このページはGoogle Summer of Code(GSoC)2016に採択された提案[Automatic-selection mechanism for data structures in MRI](https://summerofcode.withgoogle.com/projects/#4576418910437376)の成果報告ページです。

## 謝辞

このプロジェクトでメンターを務めていただいたメンターの笹田さんには4ヶ月近くに渡り連絡を取り合いながら、Rubyの内部実装からデバッグまでご協力いただき大変お世話になりました。Rubyに関するネタの引き出しはさすがに広く深く、短い期間のプロジェクトの中で実際に手を付けられたのはわずかな範囲でしたが、関連する面白いお話をたくさん聞くことができ楽しかったです。
また、Google Summer of Codeの実行に携わるみなさまも、僕を含む多くの学生に貴重な場を提供していただけたこと、感謝しています。

## 成果物
* C言語で実装されたRope拡張ライブラリの実装
  * <https://github.com/spinute/CRope> (whole repository is for this project)
* Rubyの文字列のRopeを使った内部表現の実装
  * <https://github.com/spinute/Ruby>
  * implement-ropestringブランチがこの作業ブランチです
* RubyのArray, Stringクラスのprepend, concatを多引数化するパッチ
  * <https://bugs.ruby-lang.org/issues/12333> にて議論を行い、考えられる幾つかの実装パッチを投稿しています
* Ruby内部で使われているハッシュテーブルの性能改善パッチのマージ(作業途中)

## はじめに

このページでは、RubyというとRuby処理系のうちのひとつであるMRI(Matz Ruby Interpreter)のことを指します。他の有名な処理系実装の例としては、Javaによる実装であるJRubyや、C++によりVMを実装しその他の大部分をRubyによって実装しているRubiniusなどがあり、MRIと共通する部分も多いかと思うのですが、必ずしもそうではないことにはご注意ください。

言語処理系における文字列のオブジェクトの実装の最も素朴なものとして、例えばC言語の配列などを利用し、連続したメモリ領域に文字列を保持する実装があります。
Rubyでも基本的にはこのような実装を採用しています。
他の文字列の表現として、木構造のものであるRopeというデータ構造があります。このデータ構造では文字列の削除や結合、部分文字列の取得などの操作を効率的に行うことができます。
このような複数のデータ構造には、それぞれ優位な操作がありますが、Rubyの処理系ではこのような多様なデータ構造を使い分けるデザインになっていません。
これは最も素朴のうちのひとつデータ構造であるListが用意されていないことからも理解できます。
Rubyのユーザーは多くの場合、Stack/Queue/Listなどのデータ構造の処理を全て、多用なメソッドを備えたArrayによって達成します。
ユーザーは低レベルなデータ構造の選択から解放され、より高レベルな仕事において生産性を発揮することができるのです。
一方で、用途に応じて真に効率的なデータ構造が異なり、それらを適切に使い分けることでより効率的な処理が行えることも事実です。
このプロジェクトでは、ユーザーには意識させることなく、処理系の内部でデータ構造を動的に切り替えることで、Rubyのユーザーにデータ構造の詳細を選択させない高レベルな設計とデータ操作の効率性とを両立することを目指しました。

## 背景
最終的な成果の中心としては文字列の実装として既存の配列ベースのものとは別に、Ropeと呼ばれる木構造による表現を実装し、木構造が有利な処理が文字列に適用される際には文字列の内部表現を自動的にRopeに切り替える、という処理を導入しました。
ArrayクラスまたはStringクラスにおいて実装を行う可能性があったのですが、配列ベースの実装を木構造あるいはリスト構造で表現すると、結合や削除を高速化できることがわかっており、配列よりも文字列の方が結合処理を多数繰り返す現実的な処理が多いのではないかと思い、Stringクラスにおいて実装することを選択しました。
このプロジェクトではStringクラスに木構造の内部表現を導入したのですが、リストやGapBufferなどの他の内部表現を同様に導入することや、Arrayクラスにおいて同様のことを行うことも可能だと思います。

目に見える効果として、ひとつRubyの既存の実装の問題点を例に挙げ説明をします。

既存の実装では文字列の連結に+メソッドを使うと遅く、Rubyの内部実装を知るプログラマは<<メソッドを利用することできる場面ではこちらを利用し、この問題を回避する、というハックがありました。
修正後の実装では、+メソッドを利用した際にも<<メソッドを使用した場合と大差ない性能を透過的に得られるようになりました。

これは+メソッドの振る舞いとして、a+bを行うとき、aとbを結合した後の文字列を保持するのに十分なバッファを作成し、そこにa、bの内容をコピーする処理が行われます。
一方で<<メソッドでは、a << bを行うときaの持つバッファにbをコピーします。この際にaが十分なバッファを持っている場合にはbだけがコピーされ、aのバッファが足りない時に限り新たに拡張したバッファを確保し、そこにaとbをコピーする、という処理を行います。

そのため、+では呼び出し回数だけa,bが共にコピーされ、また常に新たなオブジェクトが生成されているのに対して、<<においてはオブジェクトの生成とaのコピーはバッファが不足するときのみ発生することになります。
バッファの拡張は倍々に行われるため、例えば文字列を繰り返し2つ連結する処理を繰り返すことを考えると、コピーされる文字の量は+では最終文字列長の二乗オーダーである一方で、<<では高々2倍程度とオーダーレベルで差があります。

ここで、Ropeにおける+演算の説明を行います。
Ropeは演算の結果を遅延評価するデータ構造と考える事ができます。
今回の実装ではRopeはimmutableなデータ構造として実装しました。
Ropeの葉ノードにはStringオブジェクトを、内部ノードは連結を表現しています。
+操作自体は2つのノードを指すポインタを保持するだけなので定数時間で実行できます。
実際に連結された文字列を取り出すときに、木をトラバースし、葉に入っている文字列を集めた文字列オブジェクトを生成します。
この処理においては最終的な文字列のサイズがわかるため、先ほどの毎回の文字列のコピーや、バッファの拡張などが不要になっています。

他にも部分文字列の取得や、中間文字の削除などの演算をRope表現を持つ文字列に対して適用した場合には計算量的に優位に実行することができるようになっています。

これらの計算量的に優位なデータ構造をユーザーが明示的に利用するための拡張ライブラリは存在していましたが、これはRubyで実装されていました。
このプロジェクトの成果のひとつとして、C言語での拡張ライブラリの実装を行いました。

また、ユーザーからみて透過的にRopeが利用される、動的なデータ構造の自動選択を実装しました。
C言語などのより低レベルな言語ではユーザーはデータ構造を選択し、その実装を行い、その後そのデータ構造を利用する手順が一般的です。
一方で、Rubyのような高レベルな言語のユーザーはこのような低レベルな詳細をできれば意識したくないものかと思います。
例えば、RubyにはListが言語のコアに含まれていません。Rubyのユーザーは基本的にArrayをlist, stack, queueの代わりに多くのオペレーションを備えたarrayを使います。
しかしながら、用途に応じて真に効率的なデータ構造が異なるのも事実です。
このプロジェクトでは、Rubyのこのような特徴を尊重しながら、ユーザーに効率的なデータ処理を提供することを目指しました。

## C言語で実装されたRope拡張ライブラリ

はじめに、Ropeが文字列における一部の処理を高速化することを確認するため、拡張ライブラリとしてRopeを実装しました。

TODO: ちゃんと書く
具体的には、Ropeでは文字列の結合、削除、

一方で、添字を指定しての文字の取得は木をトラバースする必要が有るため、O(log n)程度の時間がかかります。
また、Rubyオブジェクトとしては木構造の全てのノードがそれぞれRubyのオブジェクトとなるため、Rubyのオブジェクトをノード数だけ生成するオーバーヘッドがあります。

既存のRopeの実装はRubyレベルでのものはあったものの、今回の実装はCレベルで行い、拡張ライブラリとしてRuby処理系に組み込みました。
また、オブジェクトの回収はRubyレベルではGCを使って行われているのですが、拡張ライブラリを作成する段階ではGCの動作をまだよく理解していなかったため、オブジェクトに参照カウントを埋め込んで、メモリの管理は独自に行いました。
参照カウントGCを自力で行う選択をしたことにより、文字列の結合や削除を行う際に木の内部の全てのノードの参照カウントを増減する必要が出てしまい、計算量的には結合O(n)、削除O(n)となってしまっている点は改善点です。
しかしながら、参照カウントの操作を行わないようにすると(実際にはメモリリークしているものの)理論通りの性能が出ることが確認でき、Ruby処理系に組み込む際にはRubyのGCを使いこの問題は解決されるため、ここではこの問題は放置することにしました。


## issue12333を実装したパッチの投稿
GSoCには実際にプロジェクトが始まる前の準備期間が1ヶ月ほどあり、この期間に僕はまずRubyの開発者向けドキュメントを読み、Rubyソースコード完全解説(http://i.loveruby.net/ja/rhg/book/), [Rubyのしくみ Ruby Under a Microscope](http://tatsu-zine.com/books/ruby-under-a-microscope-ja)というRubyの内部実装を解説する二冊の書籍に目を通したり、Ruby under the micro scopeの著者Patのブログを読んだりしていました。
また、オンラインにある開発者向けドキュメントとして、[Ruby C API reference](http://docs.ruby-lang.org/en/trunk/extension_rdoc.html), [Ruby Issue Tracking System](https://bugs.ruby-lang.org/projects/ruby/wiki/)などにも目を通していました。

その後、Rubyの実装に実際に修正を加える体験をしてみようということで、RubyのIssueトラッカーに投稿されたissueの中から今回の対象範囲(String/Array/Hash)に関連のありそうなもので、かつ修正の方法の目処がつくものを選定し、仕様を議論しながら実装を何種類か投稿しました。
7月のRuby開発者会議の際に開発者のみなさまにフィードバックを頂きまして、まつもとさんに機能としてはまああっていいんじゃないかという肯定的なお返事を頂き、修正パッチを投稿しました。



## Ruby文字列実装のRope対応
今回のプロジェクトの中心となる成果として、Ruby処理系における組み込みStringクラスを修正し、文字列の内部的な表現としてRopeを使うものを実装しました。
String#concatが呼ばれると文字列オブジェクトはRope表現になります。
また、配列形式の文字列が必要となる時点で、Rope表現の文字列は配列表現の文字列に変換されます。

ひとつ記録のために書いておくおくと、企画書の時点では、広いスコープで問題を定義していました。
データをどのような形式で保持するかによってそのデータの集合に対しての操作がどの程度の時間で行うことができるかが変わってきます。
例としては、単純なデータの列を保持する際に、配列としてそれを保持するのか、リストによって保持するのかによって、前者ではランダムアクセスが定数時間で行うことができるのに対して、後者では列の中間付近への新たなデータの挿入や削除に優位性があります。
Rubyでのこれまでの選択は、配列を使い、リストは提供しない、というものでした。これはユーザーから見ての簡単さという意味では優れていますが、パフォーマンスクリティカルなコードを書く際には問題となることもあるだろう、という見込みでした。
ここで、このプロジェクトの目標は、ユーザーから見るとひとつのデータ構造だが、内部では動的にデータ構造を入れ替え、複数のデータ構造の利点を併せ持つ動的なクラスを作成することでした。

オブジェクトに対してメソッドが繰り返し行われます。メソッドの引数とオブジェクトの状態に依って、メソッドのコストが決定します。
ただしここでメソッドのコストを完全に決定することは全てのメソッドで効率的に行うことができるわけではありません。
一部のメソッドではオブジェクトの状態、引数によって変化するメソッドのコストが、実際にメソッドを実行するのと同程度の複雑さでした評価できないものもあります。
一方で、一部のメソッドでは、実際に実行せずとも操作のコストを効率的に見積もることが出来ます。
例えば文字列の例で考えてみますと、文字列の長さが多くの場合の文字列の計算量的なサイズとなります。
文字列のconcatメソッドでは結合文字列の長さの和が出力文字列の長さとなり、効率よく結果を見積もることが出来ます。
一方、substrメソッドでは出力文字列の長さはそれほど簡単には見積もることができないでしょう。
さらに、ランダム性の関わるchoiceメソッドなどでは事前には正確な値を得ることはできず、せいぜい見積もりしかできなくなってしまいます。

ここで、concatメソッドのような、入力から出力のサイズが決定的/効率的にわかるようなメソッドについてはRope, List, 配列によるメソッドの実装の実行コストを実行前に比較することができます。
メソッドの実行列が与えられたとき、どの表現におけるメソッドの処理が最も効率的であるかは、動的計画法によって効率的に計算できる、というのが当初の目論見でした。

しかしながら、このアイデアはRubyにおける命令の列を先読みするような方法が現状ないということで、もう少し簡明な方法を取ることにしました。
先の手法では命令を先読みし、命令列に対しての適切な文字列表現の遷移を計算するというものでしたが、簡明版では先読みはせず、逐次の命令列に対してある表現が優位なことがわかっているメソッドが実行される際には表現を変換してから操作を実行します。

具体的にはRubyの+演算子によって文字列の結合を行う際に、結合ノードを作り、結合ノードは内部データとして長さ、右/左の子ノードのポインタ、を持つようにしました。
また、Ropeであることを示すフラグを立てて、内部ノードを表現しました。
葉ノードは既存の文字列オブジェクトを使っていますが、Ropeはimmutableなデータ構造なので、葉が変更される可能性のあるオブジェクトであるときにはimmutable化するようにしています。

このようにして作られた木構造から、文字列を実際に取り出す際に、文字列の必要な部分を実際に取り出します。
これは既存の文字列バッファを取り出す操作の中にRopeならば木をトラバースし文字列を実際に作る、という処理を挟み込むことで実現しています。
大きな文字列を作成し、実際にはその文字列の一部しか利用しない、というようなケースでは、Ropeは遅延して実際の文字列を作成するため、必要な部分だけを作成する優位性がありますが、現状では先頭を大文字にする()と、や中間文字列を抜き出す(String#substr)についてのみ実装を書き換えています。他にもこのようなメソッドはいくつかあると思うので、それらのメソッドの実装を一通り行うことはやり残されたタスクです。

TODO: 実験結果の掲載とその評価

## Rubyの内部で使用されているHashtableの実装の改良issueのマージ対応
TODO: 概要

TODO: 実験結果の掲載とその評価
