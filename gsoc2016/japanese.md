---
title: 成果報告
layout: page
parmalink: /japanese/
---

[English Page]({{site.url}}{{site.baseurl}}/gsoc2016/english)

このページは[Google Summer of Code(GSoC)](https://summerofcode.withgoogle.com/)2016に採択された提案[Automatic-selection mechanism for data structures in MRI](https://summerofcode.withgoogle.com/projects/#4576418910437376)の成果報告ページです。

## 謝辞

このプロジェクトでメンターを務めていただいたメンターの笹田さんには4ヶ月近くに渡り連絡を取り合いながら、Rubyの内部実装からデバッグまでご協力いただき大変お世話になりました。Rubyに関するネタの引き出しはさすがに広く深く、短い期間のプロジェクトの中で実際に手を付けられたのはわずかな範囲でしたが、関連する面白いお話をたくさん聞くことができ楽しかったです。
また、Google Summer of Codeの実施に携わるみなさまにも、僕を含む多くの学生にこのような貴重な場を提供していただけたこと、感謝しています。

## 成果物
* [Rope関連](#rope)
  * [C言語で実装されたRope拡張ライブラリの実装](#rope-extension)
    * Githubレポジトリ: <https://github.com/spinute/CRope> (whole repository is for this project)
  * [Rubyの文字列のRopeを使った内部表現の実装](#rope-string)
    * Githubレポジトリ: <https://github.com/spinute/Ruby>
    * implement-ropestringブランチがこの作業ブランチです
* その他
  * [RubyのArray, Stringクラスのprepend, concatを多引数化するパッチ](#issue12333)
    * Issue: <https://bugs.ruby-lang.org/issues/12333> にて議論を行い、考えられる幾つかの実装パッチを投稿しています
  * [Ruby内部で使われているハッシュテーブルの性能改善パッチの性能評価(作業途中)](#hashtable)
    * Githubレポジトリ: <https://github.com/spinute/ruby/tree/stbench/ext/stbench>

<a name="rope"></a>

# データ構造Ropeを使った文字列の実装

このプロジェクトの中心となるRubyの文字列クラスへの木構造表現の実装とその動的/自動的な切り替えの話を記述します。

## はじめに

このページでは、RubyというとRuby処理系のうちのひとつであるMRI(Matz Ruby Interpreter)のことを指します。
他の有名な処理系実装の例として、Javaによる実装であるJRubyや、C++によりVMを実装しその他の大部分をRubyによって実装しているRubiniusなどがあります。
これらの処理系についてはMRIと共通する部分も多いと思うのですが、必ずしもそうではないことにはご注意ください。

言語処理系における文字列のオブジェクトの実装として、連続したメモリ領域(例えばC言語の配列など)を使って文字列を表現するものがあります。
Rubyでも現状はこのような実装を採用しています。

他の文字列の実装として、木構造の表現であるRope[https://en.wikipedia.org/wiki/Rope_(data_structure)](Wikipedia)というデータ構造があります。(Boehm, Hans-J, Atkinson, Russ, Plass, Michael; 1995)
最も単純なレパートリーでは、木構造は二分木とし、葉は配列を素朴に使って表現した文字列を、内部ノードは自身を根とする木の葉ノードを左から順に並べた文字列を表現します。

<img src="image/rope_jp.png" alt="Rope figure" width='100%' height='auto'>

すなわち、以下のようにしてRopeによる文字列の表現から配列による文字列の表現への変換が可能です。

* ropeが葉の場合 get-string(node) = nodeの文字列
* そうでない場合 get-string(node) = get-string(nodeの左の子) + get-string(nodeの右の子)

このデータ構造では文字列の削除や結合、部分文字列の取得などの操作を配列による文字列表現の場合と比較して効率的に行うことができます。
このようにデータ構造には、それぞれ優位な操作がありますが、Rubyの処理系はユーザーに多様なデータ構造を使い分けることを課すデザインになっていません。
これは最も素朴のうちのひとつデータ構造であるListがRubyには用意されていないことからもわかります。
Rubyのユーザーは多くの場合、Stack/Queue/Listなどのデータ構造の処理を、多用なメソッドを備えたArrayによって達成します。
ユーザーは低レベルなデータ構造の選択から解放され、より高レベルな仕事において生産性を発揮することができるのです。
一方で、用途に応じて真に効率的なデータ構造が異なり、それらを適切に使い分けることでより効率的な処理が行えることも事実です。
このプロジェクトでは、従来通りユーザーには意識させることなく、処理系の内部でデータ構造を動的に切り替えることで、ユーザに対しては透過的にデータ操作の効率性を提供することを目指しました。

## 背景
最終的な成果の中心としては文字列の実装として既存の配列ベースのものとは別に、Ropeと呼ばれる木構造による表現を実装し、木構造が有利な処理が文字列に適用される際には文字列の内部表現を自動的にRopeに切り替える、という処理を導入しました。
企画段階では、ArrayクラスまたはStringクラスにおいて木構造やリスト構造の内部表現を実装する選択肢があったのですが、配列よりも文字列の方が結合処理を多数繰り返すアプリケーションが多いのではないかと考え、Stringクラスにおいて実装することを選択しました。(WebサーバーでのHTMLファイルの生成RDocによるドキュメント生成など)
このプロジェクトではHTMLファイルの生成やドキュメント生成などのRopeにおける結合処理の高速さを意識してStringクラスにRopeのような木構造の内部表現を導入しましたが、ListやGapBufferなど他の内部表現をStringクラスに実装したり、Arrayクラスにおいても同様に他のデータ構造を内部的に切り替えるようにすることも可能だと思います。

Ropeによる文字列表現の効果のひとつとして、Rubyの既存の実装における問題点を例に挙げ説明をします。

Rubyには文字列の結合を行うためのメソッドが+と<<の2種類あります。(concatというものもありますが、この実装は<<と同じです。)
前者は非破壊的に文字列を結合した結果を返すメソッドであり、後者は破壊的に文字列を結合するメソッドです。
既存の実装では前者は遅く、<<メソッドを利用することができる場面ではこちらを利用する、というハックがありました。
このプロジェクトの実装では、+メソッドを利用した際にも<<メソッドを使用した場合と大差ない性能を透過的に得られるようになりました。

2つの結合を行うメソッドの内部的な振る舞いを説明します。(実際には、短い文字列はオブジェクトの内部に埋め込まれる最適化がRubyでは行われますが、ここでは簡単のため無視しています)

<img src="image/plus_old_jp.png" alt="How plus works for now" width='100%' height='auto'>

+メソッドの振る舞いとして、a+bを行うとき、aとbを結合した後の文字列を保持するのに十分なバッファを作成し、そこにa、bの内容をコピーする処理が毎回行われます。

<img src="image/concat_jp.png" alt="How concat works" width='100%' height='auto'>

一方で<<メソッドでは、a << bを行うときaの持つバッファにbをコピーします。この際にaが十分なバッファを持っている場合にはbだけがコピーされ、aのバッファが足りない時に限り新たに拡張したバッファを確保し、そこにaとbをコピーする、という処理を行います。

そのため、+では呼び出し回数だけa,bが共にコピーされ、また常に新たなオブジェクトが生成されているのに対して、<<においてはオブジェクトの生成とaのコピーはバッファが不足するときのみ発生することになります。
バッファの拡張は指数的に行われるため、例えばある文字列を繰り返し末尾に連結する処理におけるコピーされる文字列の量を考えると、+では最終文字列長の二乗オーダーである一方で、<<では高々3倍程度とオーダーレベルで差があります。


ここで、Ropeにおける+演算の説明を行います。

<img src="image/plus_rope_jp.png" alt="How rope works" width='100%' height='auto'>

今回の実装ではRopeはimmutableなデータ構造として実装しました。
Ropeは結合演算の結果を遅延評価するデータ構造と考える事ができます。
+操作自体は2つのノードを指すポインタを保持するだけなので定数時間で実行できます。
実際に連結された文字列を取り出すときに木を辿り、葉に入っている文字列を集めた文字列オブジェクトを生成します。
この処理は実際に配列表現の文字列が必要になった時になってから実行され、最終的な文字列のサイズがわかるため、先ほどの+での結合時に毎回発生していたの文字列のコピーや、<<で必要に応じて行っていたバッファの拡張などが不要になっています。

他にも部分文字列の取得や、中間文字の削除などの演算をRope表現を持つ文字列に対して適用した場合には計算量的に優位に実行することができるようになっています。

これらの計算量的に優位なデータ構造をユーザーが明示的に利用するための拡張ライブラリは存在していましたが、これはRubyレベルで記述された拡張ライブラリでした。
このプロジェクトの成果のひとつとして、C言語での拡張ライブラリの実装を行いました。

また、ユーザーからみて透過的にRopeが利用される、動的なデータ構造の自動選択を実装しました。
C言語などのより低レベルな言語ではユーザーはデータ構造を選択し、その実装を行い、その後そのデータ構造を利用する手順が一般的です。
一方で、Rubyのような高レベルな言語のユーザーはこのような低レベルな詳細をできれば意識したくないものかと思います。
例えば、RubyにはListが言語のコアに含まれていません。Rubyのユーザーは基本的にArrayをlist, stack, queueの代わりに多くのオペレーションを備えたarrayを使います。
しかしながら、用途に応じて真に効率的なデータ構造が異なるのも事実です。
このプロジェクトでは、Rubyのこのような特徴を尊重しながら、ユーザーに効率的なデータ処理を提供することを目指しました。

<a name='rope-extension'></a>

## C言語で実装されたRope拡張ライブラリ

はじめに、Ropeが文字列における一部の処理を高速化することを確認するため、拡張ライブラリとしてRopeを実装しました。

今回はC言語で実装したRopeをRubyでラップする形で実装を行いました。
CData型というC言語の構造体をRubyオブジェクトのデータとして持たせるための型があり、これを利用しました。
Rope構造体はメンバ変数として、左右の子を指すポインタと、自身を根とする木構造の表現する文字列の長さを持っています。

TODO: ちゃんと書く
具体的には、Ropeでは文字列の結合、削除、部分文字列の取得を

一方で、添字を指定しての文字の取得は木をトラバースする必要が有るため、O(log n)程度の時間がかかります。
また、Rubyオブジェクトとしては木構造の全てのノードがそれぞれRubyのオブジェクトとなるため、Rubyのオブジェクトをノード数だけ生成するオーバーヘッドがあります。

既存のRopeの実装はRubyレベルでのものはあったものの、今回の実装はCレベルで行い、拡張ライブラリとしてRuby処理系に組み込みました。
また、オブジェクトの回収はRubyレベルではGCを使って行われているのですが、拡張ライブラリを作成する段階ではGCの動作をまだよく理解していなかったため、オブジェクトに参照カウントを埋め込んで、メモリの管理は独自に行いました。
参照カウントGCを自力で行う選択をしたことにより、文字列の結合や削除を行う際に木の内部の全てのノードの参照カウントを増減する必要が出てしまい、計算量的には結合O(n)、削除O(n)となってしまっている点は改善点です。
しかしながら、参照カウントの操作を行わないようにすると(実際にはメモリリークしているものの)理論通りの性能が出ることが確認でき、Ruby処理系に組み込む際にはRubyのGCを使いこの問題は解決されるため、ここではこの問題は放置することにしました。

<a name='rope-string'></a>

## Ruby文字列実装のRope対応
今回のプロジェクトの中心となる成果として、Ruby処理系における組み込みStringクラスを修正し、文字列の内部的な表現としてRopeを使うものを実装しました。
Rubyのオブジェクトの状態を示すフラグに、文字列オブジェクトがロープであることを示すフラグを作りました。(FL_USER_0をSTR_IS_ROPEとした)
String#concatが呼ばれ、埋め込み文字列で表現可能な長さを越える文字列が生成される場合には、その出力はRope表現になります。
この際に、子ノードが変更可能なものである場合には、変更不可能なものとします。(Ruby文字列にはCopy on Writeもあるので気をつける必要があります。)
また、配列形式の文字列が必要となる時点で、Rope表現の文字列は配列表現の文字列に変換されます。

ひとつ記録のために書いておくと、企画書の時点では、広いスコープで問題を定義していました。
データをどのような形式で保持するかによってそのデータの集合に対しての操作がどの程度の時間で行うことができるかが変わってきます。
例としては、単純なデータの列を保持する際に、配列としてそれを保持するのか、リストによって保持するのかによって、前者ではランダムアクセスが定数時間で行うことができるのに対して、後者では列の中間付近への新たなデータの挿入や削除に優位性があります。
Rubyでのこれまでの選択は、配列を使い、リストは提供しない、というものでした。これはユーザーから見ての簡単さという意味では優れていますが、パフォーマンスクリティカルなコードを書く際には問題となることもあるだろう、という見込みでした。
ここで、このプロジェクトの目標は、ユーザーから見るとひとつのデータ構造だが、内部では動的にデータ構造を入れ替え、複数のデータ構造の利点を併せ持つ動的なクラスを作成することでした。

オブジェクトに対してメソッドが繰り返し行われます。メソッドの引数とオブジェクトの状態に依って、メソッドのコストが決定します。
ただしここでメソッドのコストを完全に決定することは全てのメソッドで効率的に行うことができるわけではありません。
一部のメソッドではオブジェクトの状態、引数によって変化するメソッドのコストが、実際にメソッドを実行するのと同程度の複雑さでした評価できないものもあります。
一方で、一部のメソッドでは、実際に実行せずとも操作のコストを効率的に見積もることが出来ます。
例えば文字列の例で考えてみますと、文字列の長さが多くの場合の文字列の計算量的なサイズとなります。
文字列のconcatメソッドでは結合文字列の長さの和が出力文字列の長さとなり、効率よく結果を見積もることが出来ます。
一方、substrメソッドでは出力文字列の長さはそれほど簡単には見積もることができないでしょう。
さらに、ランダム性の関わるchoiceメソッドなどでは事前には正確な値を得ることはできず、せいぜい見積もりしかできなくなってしまいます。

ここで、concatメソッドのような、入力から出力のサイズが決定的/効率的にわかるようなメソッドについてはRope, List, 配列によるメソッドの実装の実行コストを実行前に比較することができます。
メソッドの実行列が与えられたとき、どの表現におけるメソッドの処理が最も効率的であるかは、動的計画法によって効率的に計算できる、というのが当初の目論見でした。

しかしながら、このアイデアはRubyにおける命令の列を先読みするような方法が現状ないということで、もう少し簡明な方法を取ることにしました。
先の手法では命令を先読みし、命令列に対しての適切な文字列表現の遷移を計算するというものでしたが、簡明版では先読みはせず、逐次の命令列に対してある表現が優位なことがわかっているメソッドが実行される際には表現を変換してから操作を実行します。

具体的にはRubyの+演算子によって文字列の結合を行う際に、結合ノードを作り、結合ノードは内部データとして長さ、右/左の子ノードのポインタ、を持つようにしました。
また、Ropeであることを示すフラグを立てて、内部ノードを表現しました。
葉ノードは既存の文字列オブジェクトを使っていますが、Ropeはimmutableなデータ構造なので、葉が変更される可能性のあるオブジェクトであるときにはimmutable化するようにしています。

このようにして作られた木構造から、文字列を実際に取り出す際に、文字列の必要な部分を実際に取り出します。
これは既存の文字列バッファを取り出す操作の中にRopeならば木をトラバースし文字列を実際に作る、という処理を挟み込むことで実現しています。
大きな文字列を作成し、実際にはその文字列の一部しか利用しない、というようなケースでは、Ropeは遅延して実際の文字列を作成するため、必要な部分だけを作成する優位性がありますが、現状では先頭を大文字にする()と、や中間文字列を抜き出す(String#substr)についてのみ実装を書き換えています。他にもこのようなメソッドはいくつかあると思うので、それらのメソッドの実装を一通り行うことはやり残されたタスクです。

また、他にも、文字列の繰り返し(String#*)なども同様の方法で遅延が可能です。
str*10000などをすると、既存の実装ではこの処理の実行時にstrの10000倍の長さを持つ配列が確保されることになるのですが、Ropeでは結果の文字列を実際に配列として使うまで、配列を確保しません。
この最適化は実装したのですが、実際に頻繁に役に立つケースかは疑問です。

具体的にはまた、配列全体を使わない場合には一部分だけを作成します。(Capitalizeや[]によるindexingなど)

TODO: 実験結果の掲載とその評価

<a name="issue12333"></a>

# issue12333を実装したパッチの投稿
GSoCには実際にプロジェクトが始まる前の準備期間が1ヶ月ほどあり、この期間に僕はまずRubyの開発者向けドキュメントを読み、Rubyソースコード完全解説(http://i.loveruby.net/ja/rhg/book/), [Rubyのしくみ Ruby Under a Microscope](http://tatsu-zine.com/books/ruby-under-a-microscope-ja)というRubyの内部実装を解説する二冊の書籍に目を通したり、Ruby under the micro scopeの著者Patのブログを読んだりしていました。
また、オンラインにある開発者向けドキュメントとして、[Ruby C API reference](http://docs.ruby-lang.org/en/trunk/extension_rdoc.html), [Ruby Issue Tracking System](https://bugs.ruby-lang.org/projects/ruby/wiki/)などにも目を通していました。

その後、Rubyの実装に実際に修正を加える体験をしてみようということで、RubyのIssueトラッカーに投稿されたissueの中から今回の対象範囲(String/Array/Hash)に関連のありそうなもので、かつ修正の方法の目処がつくものとして<https://bugs.ruby-lang.org/issues/12333>を選定し、仕様を議論しながら実装を何種類か投稿しました。

一考する余地のあった点としては、結合処理の際に、自身を引数に取るような実行をどのように処理するのが整合的な振るまいか、という点です。

```ruby
str = "a"
str.concat(str, str)
```

のようなプログラムを実行した際に、strは最終的に"aaa"となるべきか、あるいは"aaaa"になるべきか、というものです。
おそらくプログラムの意図としては前者が自然なのではないかと思うのですが、後者にはstr.(str); str(str)というように二度メソッドを呼んだときの結果と一致する、という意味では整合性があります。
いずれのパッチも実装し、 7月のRuby開発者会議の際に開発者のみなさまにご意見を頂いたところ、前者が自然でいいだろう、とのご意見をいただきました。

また、コーディングスタイルについていくつかご指摘を頂いたので、その点を修正したパッチも再度投稿しました。

<a name='hashtable'></a>

## Rubyの内部で使用されているHashtableの実装の改良issueのマージ対応

<https://github.com/spinute/ruby/tree/stbench/ext/stbench>

このプロジェクトの最後の1週間ほどで、https://bugs.ruby-lang.org/issues/12142 の評価を行うことを試みました。

このissueでは、Rubyのhasttableの実装を改良しようという提案です。
Vladimir Makarov氏がopen addressingを使った実装を公開し、議論を行う中で、Yura Sokolov氏がopen addressingを利用せずに先の実装に近い性能を出す別の実装を公開し、2つの実装と既存の実装との評価比較が待たれている状態です。
両者とも数ヶ月の議論を経て実装が洗練されてきており、Rubyへのマージされることになれば価値の高い案件であると思い、最後の1週間でこのissueのマージ作業に貢献できるのではないかと考え、この作業に取り組むことにしました。

Rubyに付属するベンチマークに既にいくつかの処理がRubyで記述されていますが、ハッシュテーブルレベルでの単一の操作の性能評価をするベンチマークを書くことで、より定量的な比較が可能になるのではないかという狙いでこのベンチマークを実装することに決めました。

実装としては、Rubyの拡張ライブラリとしてベンチマークを行うためのダミーのクラスを作り、そこからCで記述したシナリオをRubyレベルで渡したパラメータで選び、ベンチマークの実行はCの関数で完結するように書いてあります。ちなみに拡張ライブラリとして記述することにしたのは、Rubyのソースコードと結合のあるRubyのハッシュテーブルのコード(st.c)のビルドを簡単に行うためです。

現状の機能としましては、

* 処理回数
* テーブルの初期サイズ
* キーの種類 := 整数、(長い、短い)文字列
* キーの選択 := 全て同じもの、全て別のもの、母集団からランダムに選ぶ
* オペレーション := insert、delete、search、テーブルの初期化&削除

の組み合わせについてベンチマークを実行できるようにしました。

現在は実行時間と、ベンチマーク前後のmaxRSSを取っています。

ベンチマークを実行するプログラムの例としては以下のようになります。(bench.rbに小さなベンチマークを一通りの組み合わせに対して実行するプログラムが記述してあります。)

```ruby
keytype='num'; ht_init_size=0, scale=10; patter='rand'
pid = Process.fork do
  bench = STBench.new
  bench.search_setup keytype, ht_init_size, scale, pattern
  puts Benchmark.measure { bench.search_run }
    bench.search_cleanup
  end
Process.waitpid pid
```

下のような結果が出ます。(一行目がパラメータ->キーが整数、キーはランダム、10 * 00000回、挿入する、テーブルの初期サイズは未指定、で二行目が実行時間、三行目がr_usageから取ったMaxRSS(初期化完了時、ベンチマーク完了後、それらの増分)です。)

<pre>
Insert bench: keytype=num,    pattern=rand,   scale=10,    ht_init_size=0, keylen=5
  0.890000   0.040000   0.930000 (  0.933727)
  before:    4730880, after:   39747584, diff  35016704
</pre>

ハッシュテーブルのAPIに含まれているforearch系の関数に対してのシナリオを記述し、各パッチと既存の実装とのベンチマークを取り、その評価を行うのは今後の課題です。
